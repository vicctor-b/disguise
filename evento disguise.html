<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Quiz de Monstros - Ragnarok</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      color: #fff;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      overflow-x: hidden; /* Evita scroll horizontal */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .main-container {
      display: flex;
      gap: 30px;
      max-width: 1060px;
      width: 100%;
      align-items: stretch; /* Faz os dois painéis terem a mesma altura */
      justify-content: center;
      margin: 0 auto;
    }
    
    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      width: 500px;
      min-width: 500px;
      max-width: 500px;
      text-align: center;
      height: 80vh;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }
    
    .history-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      width: 500px;
      min-width: 500px;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      height: 80vh;
      max-height: 80vh;
    }
    
    .history-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 5px;
      min-height: 0; /* Permite que o flex funcione corretamente */
      max-height: calc(80vh - 100px); /* Altura máxima menos espaço para título e padding */
    }
    
    .history-panel h3 {
      color: #ffd700;
      text-align: center;
      margin: 0 0 20px 0;
      font-size: 1.2em;
      flex-shrink: 0; /* Evita que o título seja comprimido */
    }
    
    .history-item {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 15px;
      border-left: 4px solid;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .history-item.correct {
      border-left-color: #4ade80;
    }
    
    .history-item.incorrect {
      border-left-color: #f87171;
    }
    
    .history-item.timeout {
      border-left-color: #ffd700;
    }
    
    .history-item.reveal {
      border-left-color: #6366f1;
    }
    
    .history-item img {
      width: 120px;
      height: 120px;
      object-fit: cover;
      border-radius: 10px;
      margin: 0 auto 15px auto;
      display: block;
    }
    
    .history-item .monster-name {
      font-weight: bold;
      color: #fff;
      margin-bottom: 8px;
      font-size: 16px;
      word-break: break-word;
      text-align: center;
    }
    
    .history-item .result {
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    .history-item.correct .result {
      color: #4ade80;
    }
    
    .history-item.incorrect .result {
      color: #f87171;
    }
    
    .history-item.timeout .result {
      color: #ffd700;
    }
    
    .history-item.reveal .result {
      color: #6366f1;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .main-container {
        flex-direction: column;
        align-items: center;
        max-width: 100%;
      }
      
      .container {
        width: 100%;
        min-width: auto;
        max-width: 500px;
        order: 1;
      }
      
      .history-panel {
        width: 100%;
        min-width: auto;
        max-width: 500px;
        order: 2;
        margin-top: 20px;
        height: 60vh;
        max-height: 60vh;
      }
    }
    
    h1 {
      font-size: 2em;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      background: linear-gradient(45deg, #ffd700, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      flex-shrink: 0;
    }
    
    .image-container {
      position: relative;
      margin: 15px auto;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 150px;
      flex-shrink: 0;
    }
    
    img {
      max-width: 150px;
      max-height: 150px;
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    img:hover {
      transform: scale(1.05);
    }
    
    .loading {
      display: none;
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .input-container {
      margin: 15px 0;
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      flex-shrink: 0;
    }
    
    input {
      padding: 15px 20px;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      outline: none;
      transition: all 0.3s ease;
      flex: 1;
      min-width: 200px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    input:focus {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: rgba(255, 255, 255, 1);
    }
    
    input:disabled {
      background: rgba(150, 150, 150, 0.3);
      color: #888;
      cursor: not-allowed;
      transform: none;
    }
    
    button {
      padding: 15px 25px;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #f7931e, #ff6b35);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      background: rgba(150, 150, 150, 0.5);
      cursor: not-allowed;
      transform: none;
      opacity: 0.6;
    }
    
    button:disabled:hover {
      background: rgba(150, 150, 150, 0.5);
      transform: none;
    }
    
    .reveal-btn {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      padding: 15px 20px;
      font-size: 14px;
    }
    
    .reveal-btn:hover {
      background: linear-gradient(45deg, #8b5cf6, #6366f1);
    }
    
    .answer {
      font-size: 16px;
      font-weight: bold;
      margin: 15px 0;
      padding: 12px;
      border-radius: 15px;
      background: transparent;
      min-height: 45px;
      max-height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
      text-align: center;
      line-height: 1.2;
      flex-shrink: 0;
    }
    
    .answer.has-content {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    
    .answer.correct {
      color: #4ade80;
      border: 2px solid #4ade80;
    }
    
    .answer.incorrect {
      color: #f87171;
      border: 2px solid #f87171;
    }
    
    .answer.reveal {
      color: #ffd700;
      border: 2px solid #ffd700;
    }
    
    .timer {
      font-size: 20px;
      font-weight: bold;
      color: #ffd700;
      margin: 15px 0;
      padding: 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      border: 2px solid #ffd700;
      text-shadow: 0 0 10px #ffd700;
      flex-shrink: 0;
    }
    
    .timer.warning {
      color: #ff6b35;
      border-color: #ff6b35;
      text-shadow: 0 0 10px #ff6b35;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .attempts {
      margin-top: 15px;
      text-align: left;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      padding: 12px;
      max-height: 120px;
      min-height: 40px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }
    
    .attempts h3 {
      margin: 0 0 10px 0;
      color: #ffd700;
      text-align: center;
    }
    
    .attempt {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 8px;
      background: rgba(248, 113, 113, 0.2);
      border-left: 4px solid #f87171;
      color: #f87171;
    }
    
    .attempts::-webkit-scrollbar {
      width: 6px;
    }
    
    .attempts::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    
    .attempts::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    
    .history-panel::-webkit-scrollbar {
      width: 0; /* Remove o scroll do painel principal */
    }
    
    .history-panel::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .history-panel::-webkit-scrollbar-thumb {
      background: transparent;
    }
    
    .history-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .history-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    
    .history-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="container">
      <h1>Qual é o monstro?</h1>
      
      <div class="answer" id="answer"></div>
      
      <div class="image-container">
        <div class="loading" id="loading"></div>
        <img id="monster-img" src="" alt="Monstro" style="display: none;">
      </div>
      
      <div class="input-container">
        <input type="text" id="guess" placeholder="Digite o nome do monstro" autocomplete="off">
        <button onclick="checkAnswer()">Enviar</button>
        <button onclick="revealAnswer()" class="reveal-btn">Revelar</button>
      </div>
      
      <div class="timer" id="timer">Tempo restante: 20</div>
      
      <div class="attempts" id="attempts" style="display: none;">
        <h3>❌ Tentativas Erradas:</h3>
        <div id="attempts-list"></div>
      </div>
    </div>
    
    <div class="history-panel">
      <h3>📚 Histórico de Monstros</h3>
      <div class="history-content">
        <div id="monster-history"></div>
      </div>
    </div>
  </div>

  <script>
    const proxyUrl = "http://localhost:3000/monster"; // Proxy local
    let monsterData = null;
    let timer = 20;
    let countdown;
    let wrongAttempts = [];
    let monsterHistory = [];
    let currentMonsterResult = null;
    let isAnswered = false; // Flag para controlar se já foi respondido

    // Função para tratar o nome do monstro
    function formatMonsterName(name) {
      if (!name) return "Desconhecido";
      return name.replace(/_/g, ' ').trim();
    }

    // Função para normalizar texto para comparação
    function normalizeText(text) {
      return text.toLowerCase()
        .replace(/_/g, ' ')
        .replace(/[^a-z0-9\s]/g, '')
        .trim();
    }

    // Event listener para Enter
    document.addEventListener('DOMContentLoaded', function() {
      const input = document.getElementById('guess');
      input.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !isAnswered) {
          checkAnswer();
        }
      });
    });

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
      document.getElementById('monster-img').style.display = 'none';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('monster-img').style.display = 'block';
    }

    function addToHistory(monster, result, attempts = []) {
      const historyItem = {
        monster: monster,
        result: result,
        attempts: attempts,
        timestamp: new Date()
      };
      
      // Adiciona no início do array (mais recente primeiro)
      monsterHistory.unshift(historyItem);
      
      // Limita o histórico a 8 itens para não crescer demais
      if (monsterHistory.length > 8) {
        monsterHistory = monsterHistory.slice(0, 8);
      }
      
      updateHistoryDisplay();
    }

    function updateHistoryDisplay() {
      const historyContainer = document.getElementById('monster-history');
      historyContainer.innerHTML = '';
      
      if (monsterHistory.length === 0) {
        historyContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px; font-style: italic;">Nenhum monstro ainda...</div>';
        return;
      }
      
      monsterHistory.forEach(item => {
        const historyDiv = document.createElement('div');
        historyDiv.className = `history-item ${item.result}`;
        
        const resultIcon = item.result === 'correct' ? '✅' : 
                          item.result === 'timeout' ? '⏰' : 
                          item.result === 'reveal' ? '🔍' : '❌';
        const resultText = item.result === 'correct' ? 'Acertou!' : 
                          item.result === 'timeout' ? 'Tempo esgotado' : 
                          item.result === 'reveal' ? 'Revelado' :
                          `${item.attempts.length} tentativa(s) errada(s)`;
        
        historyDiv.innerHTML = `
          <img src="${item.monster.gif || ''}" alt="${formatMonsterName(item.monster.monster_info)}" onerror="this.style.display='none'">
          <div class="monster-name">${formatMonsterName(item.monster.monster_info)}</div>
          <div class="result">${resultIcon} ${resultText}</div>
        `;
        
        historyContainer.appendChild(historyDiv);
      });
    }

    async function getRandomMonster() {
      // Adiciona o monstro anterior ao histórico se existir
      if (monsterData && currentMonsterResult) {
        addToHistory(monsterData, currentMonsterResult, wrongAttempts);
      }
      
      showLoading();
      clearInterval(countdown);
      
      // Reset da interface
      const answerElement = document.getElementById("answer");
      answerElement.textContent = "";
      answerElement.className = "answer";
      document.getElementById("guess").value = "";
      document.getElementById("attempts").style.display = "none";
      document.getElementById("attempts-list").innerHTML = "";
      wrongAttempts = [];
      currentMonsterResult = null;
      isAnswered = false; // Reset do flag
      
      // Reabilita input e botões
      document.getElementById("guess").disabled = false;
      document.querySelector('button[onclick="checkAnswer()"]').disabled = false;
      document.querySelector('button[onclick="revealAnswer()"]').disabled = false;
      
      // Limpa a variável da imagem do monstro anterior
      monsterData = null;
      
      timer = 20;
      updateTimer();

      // Gera ID aleatório
      const randomId = Math.floor(Math.random() * (2000 - 1001) + 1001);

      try {
        const response = await fetch(`${proxyUrl}/${randomId}`);
        if (!response.ok) throw new Error("Erro ao buscar monstro");

        monsterData = await response.json();

        // Exibir imagem
        const img = document.getElementById("monster-img");
        img.src = monsterData.gif || "";
        img.alt = formatMonsterName(monsterData.monster_info) || "Monstro";
        
        hideLoading();
        startCountdown();
      } catch (error) {
        console.error(error);
        hideLoading();
        setTimeout(() => getRandomMonster(), 1000); // tenta novamente após 1 segundo
      }
    }

    function updateTimer() {
      const timerElement = document.getElementById("timer");
      timerElement.textContent = `Tempo restante: ${timer}`;
      
      if (timer <= 5) {
        timerElement.classList.add('warning');
      } else {
        timerElement.classList.remove('warning');
      }
    }

    function startCountdown() {
      countdown = setInterval(() => {
        timer--;
        updateTimer();
        
        if (timer <= 0) {
          clearInterval(countdown);
          currentMonsterResult = 'timeout';
          showAnswer();
        }
      }, 1000);
    }

    function showAnswer() {
      const name = formatMonsterName(monsterData?.monster_info) || "Desconhecido";
      const answerElement = document.getElementById("answer");
      answerElement.textContent = `⏰ Tempo acabou, eu era: ${name}`;
      answerElement.className = "answer reveal has-content";
      
      // Trava input e botões
      isAnswered = true;
      document.getElementById("guess").disabled = true;
      document.querySelector('button[onclick="checkAnswer()"]').disabled = true;
      document.querySelector('button[onclick="revealAnswer()"]').disabled = true;
      
      // Aguarda 5 segundos antes de mudar o monstro para dar tempo de ver a resposta
      setTimeout(getRandomMonster, 5000);
    }

    function revealAnswer() {
      if (!monsterData || isAnswered) return; // Não faz nada se não há monstro ou já foi respondido
      
      clearInterval(countdown);
      currentMonsterResult = 'reveal'; // Novo tipo de resultado
      
      const name = formatMonsterName(monsterData?.monster_info) || "Desconhecido";
      const answerElement = document.getElementById("answer");
      answerElement.textContent = `🔍 Eu era: ${name}`;
      answerElement.className = "answer reveal has-content";
      
      // Trava input e botões
      isAnswered = true;
      document.getElementById("guess").disabled = true;
      document.querySelector('button[onclick="checkAnswer()"]').disabled = true;
      document.querySelector('button[onclick="revealAnswer()"]').disabled = true;
      
      // Limpa o campo de input
      document.getElementById("guess").value = "";
      
      // Aguarda 3 segundos antes de mudar o monstro
      setTimeout(getRandomMonster, 3000);
    }

    function addWrongAttempt(attempt) {
      wrongAttempts.unshift(attempt); // Adiciona no início (mais recente primeiro)
      
      // Limita a 5 tentativas para não crescer demais
      if (wrongAttempts.length > 5) {
        wrongAttempts = wrongAttempts.slice(0, 5);
      }
      
      const attemptsContainer = document.getElementById("attempts");
      const attemptsList = document.getElementById("attempts-list");
      
      // Limpa a lista e reconstrói (para manter ordem mais recente primeiro)
      attemptsList.innerHTML = '';
      wrongAttempts.forEach(wrongAttempt => {
        const attemptDiv = document.createElement('div');
        attemptDiv.className = 'attempt';
        attemptDiv.textContent = `❌ ${wrongAttempt}`;
        attemptsList.appendChild(attemptDiv);
      });
      
      attemptsContainer.style.display = 'block';
    }

    function checkAnswer() {
      const input = document.getElementById("guess");
      const guess = input.value.trim();
      
      if (!guess || isAnswered) return; // Não faz nada se input vazio ou já foi respondido
      
      const guessNormalized = normalizeText(guess);
      const correctNormalized = normalizeText(monsterData?.monster_info || '');
      const answerElement = document.getElementById("answer");
      
      // Limpa o input imediatamente
      input.value = "";
      
      if (guessNormalized === correctNormalized) {
        const correctName = formatMonsterName(monsterData?.monster_info) || "Desconhecido";
        answerElement.textContent = `✅ Acertou! Eu era: ${correctName}`;
        answerElement.className = "answer correct has-content";
        currentMonsterResult = 'correct';
        clearInterval(countdown);
        
        // Trava input e botões após acertar
        isAnswered = true;
        input.disabled = true;
        document.querySelector('button[onclick="checkAnswer()"]').disabled = true;
        document.querySelector('button[onclick="revealAnswer()"]').disabled = true;
        
        // Aguarda 3 segundos antes de mudar o monstro
        setTimeout(getRandomMonster, 3000);
      } else {
        // Não mostra mensagem de erro, apenas adiciona à lista de tentativas
        currentMonsterResult = 'incorrect';
        addWrongAttempt(guess);
      }
      
      // Foca novamente no input apenas se não foi respondido
      if (!isAnswered) {
        input.focus();
      }
    }

    // Inicia o jogo
    getRandomMonster();
  </script>
</body>
</html>
